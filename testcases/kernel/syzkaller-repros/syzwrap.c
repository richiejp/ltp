// SPDX-License-Identifier: GPL-2.0-or-later
/*
 * Copyright (c) 2019 Richard Palethorpe <rpalethorpe@suse.com>
 *
 * Run a single reproducer generated by the Syzkaller fuzzer.
 *
 * Much of the code here is adapted from Syzkaller's "executor".
 */

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/prctl.h>
#include <sched.h>
#include <signal.h>
#include <stdio.h>
#include <pwd.h>

#include "tst_test.h"
#include "tst_taint.h"
#include "tst_safe_stdio.h"

#include "create_network.h"

static char *dir;
static char *name;
static char *path;

static struct tst_option options[] = {
	{"d:", &dir, "Mandatory directory containing reproducers"},
	{"n:", &name, "Mandatory executable name of reproducer"},
	{NULL, NULL, NULL}
};

static void become_nobody(void)
{
	struct passwd *pw;
	int gid, uid;

	setgroups(0, NULL);

	pw = getpwnam("nobody");
	if (pw) {
		gid = pw->pw_gid;
		uid = pw->pw_uid;
	} else {
		gid = 65534;
		uid = 65534;
	}

	setregid(gid, gid);
	setreuid(uid, uid);
}

static void setup(void)
{
	tst_taint_init(TST_TAINT_W | TST_TAINT_D | TST_TAINT_L);

	if (!dir)
		tst_brk(TBROK, "No reproducer directory specified");

	if (!name)
		tst_brk(TBROK, "No reproducer name specified");

	tst_res(TINFO, "https://syzkaller.appspot.com/bug?id=%s", name);

	SAFE_ASPRINTF(&path, "%s/%s", dir, name);
	tst_res(TINFO, "%s", path);
}

static void run(void)
{
	unsigned int backoff = 100;
	int rem, status, sent_kill = 0;
	float exec_time_start = (float)tst_timeout_remaining();
	int pid;

	if (unshare(CLONE_NEWPID)) {
		tst_res(TWARN | TERRNO,
			"Failed to create new PID namespace; reproducer will share PIDs with the parent namespace");
	}

	pid = SAFE_FORK();
	if (!pid) {
		create_network();
		become_nobody();

		if (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0)) {
			tst_res(TWARN | TERRNO,
				"Failed to set dumpable; won't be able to open /proc/self/*");
		}

		execl(path, name, NULL);
		tst_brk(TBROK | TERRNO, "Failed to exec reproducer");
	}

	while (!waitpid(pid, &status, WNOHANG)) {
		rem = tst_timeout_remaining();

		if (!sent_kill && rem / exec_time_start < 0.5) {
			tst_res(TINFO, "Timeout; killing reproducer");

			TEST(kill(pid, SIGKILL));
			if (TST_RET == -1)
				tst_res(TWARN | TTERRNO, "kill() failed");
			else
				sent_kill = 1;
		}

		usleep(backoff);
		backoff = MIN(2 * backoff, 1000000);
	}

	if (tst_taint_check()) {
		tst_res(TFAIL, "Kernel is tainted");
	} else {
		tst_res(TPASS, "Kernel is not tainted");
	}
}

static struct tst_test test = {
	.setup = setup,
	.test_all = run,
	.options = options,
	.needs_tmpdir = 1,
	.forks_child = 1,
};
