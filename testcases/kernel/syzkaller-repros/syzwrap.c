// SPDX-License-Identifier: GPL-2.0-or-later
/*
 * Copyright (c) 2019 Richard Palethorpe <rpalethorpe@suse.com>
 *
 * Run a single reproducer generated by the Syzkaller fuzzer.
 *
 * Much of the code here is adapted from Syzkaller's "executor".
 */

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/prctl.h>
#include <sched.h>
#include <signal.h>
#include <stdio.h>
#include <pwd.h>

#include <linux/rtnetlink.h>

#include "tst_test.h"
#include "tst_taint.h"
#include "tst_netlink.h"
#include "tst_safe_stdio.h"

struct nlmsg_writer {
	char *pos;
	unsigned int depth;
	struct nlattr* stack[8];
	char buf[BUFSIZ];
};

static char *dir;
static char *name;
static char *path;

static struct nlmsg_writer *msg;

static struct tst_option options[] = {
	{"d:", &dir, "Mandatory directory containing reproducers"},
	{"n:", &name, "Mandatory executable name of reproducer"},
	{NULL, NULL, NULL}
};

static void nlmsg_write_head(uint16_t type, uint16_t flags,
			     const void *data, uint32_t size)
{
	struct nlmsghdr* hdr = (struct nlmsghdr*)msg->buf;

	memset(msg, 0, sizeof(*msg));

	hdr->nlmsg_type = type;
	hdr->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | flags;

	memcpy(hdr + 1, data, size);

	msg->pos = (char *)(hdr + 1) + NLMSG_ALIGN(size);
}

static void nlmsg_write_attr(uint16_t type, const void* data, int size)
{
	struct nlattr* attr = (struct nlattr*)msg->pos;

	attr->nla_len = sizeof(*attr) + size;
	attr->nla_type = type;

	memcpy(attr + 1, data, size);

	msg->pos += NLMSG_ALIGN(attr->nla_len);
}

static void nlmsg_push_attr(uint16_t type)
{
	struct nlattr* attr = (struct nlattr*)msg->pos;

	attr->nla_type = type;

	msg->pos += sizeof(*attr);
	msg->stack[msg->depth++] = attr;
}

static void nlmsg_pop_attr(void)
{
	struct nlattr* attr = msg->stack[--msg->depth];

	attr->nla_len = msg->pos - (char*)attr;
}

static int nlmsg_send(int sock)
{
	struct nlmsghdr* hdr = (struct nlmsghdr*)msg->buf;
	struct sockaddr_nl addr;
	unsigned n;

	if (msg->pos > msg->buf + sizeof(msg->buf) || msg->depth)
		tst_res(TBROK, "nlmsg attribute overflow/bad nesting");

	hdr->nlmsg_len = msg->pos - msg->buf;

	memset(&addr, 0, sizeof(addr));
	addr.nl_family = AF_NETLINK;

	SAFE_SENDTO(1, sock, msg->buf, hdr->nlmsg_len, 0, (struct sockaddr*)&addr, sizeof(addr));

	n = recv(sock, msg->buf, sizeof(msg->buf), 0);
	if (n < sizeof(struct nlmsghdr) + sizeof(struct nlmsgerr))
		tst_brk(TBROK, "short netlink read: %d", n);
	if (hdr->nlmsg_type != NLMSG_ERROR)
		tst_brk(TBROK, "short netlink ack: %d", hdr->nlmsg_type);

	return -((struct nlmsgerr*)(hdr + 1))->error;
}

static void nl_add_device(int sock, const char* type, const char* name)
{
	struct ifinfomsg hdr;

	memset(&hdr, 0, sizeof(hdr));
	nlmsg_write_head(RTM_NEWLINK, NLM_F_EXCL | NLM_F_CREATE, &hdr, sizeof(hdr));
	if (name)
		nlmsg_write_attr(IFLA_IFNAME, name, strlen(name));
	nlmsg_push_attr(IFLA_LINKINFO);
	nlmsg_write_attr(IFLA_INFO_KIND, type, strlen(type));
	nlmsg_pop_attr();

	int err = nlmsg_send(sock);
	tst_res(TINFO, "netlink: adding device %s type %s: %s\n", name, type, strerror(err));

	(void)err;
}

static void become_nobody(void)
{
	struct passwd *pw;
	int gid, uid;

	setgroups(0, NULL);

	pw = getpwnam("nobody");
	if (pw) {
		gid = pw->pw_gid;
		uid = pw->pw_uid;
	} else {
		gid = 65534;
		uid = 65534;
	}

	setregid(gid, gid);
	setreuid(uid, uid);
}

static void virtual_network(void)
{
	int sock;

	if (unshare(CLONE_NEWNET))
		tst_brk(TBROK | TERRNO, "Failed to create new network namespace");

	sock = SAFE_SOCKET(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);

	nl_add_device(sock, "bridge", "bridge0");

	SAFE_CLOSE(sock);
}

static void setup(void)
{
	tst_taint_init(TST_TAINT_W | TST_TAINT_D | TST_TAINT_L);

	if (!dir)
		tst_brk(TBROK, "No reproducer directory specified");

	if (!name)
		tst_brk(TBROK, "No reproducer name specified");

	tst_res(TINFO, "https://syzkaller.appspot.com/bug?id=%s", name);

	SAFE_ASPRINTF(&path, "%s/%s", dir, name);
	tst_res(TINFO, "%s", path);
}

static void run(void)
{
	unsigned int backoff = 100;
	int rem, status, sent_kill = 0;
	float exec_time_start = (float)tst_timeout_remaining();
	int pid;

	if (unshare(CLONE_NEWPID)) {
		tst_res(TWARN | TERRNO,
			"Failed to create new PID namespace; reproducer will share PIDs with the parent namespace");
	}

	pid = SAFE_FORK();
	if (!pid) {
		virtual_network();

		become_nobody();

		if (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0)) {
			tst_res(TWARN | TERRNO,
				"Failed to set dumpable; won't be able to open /proc/self/*");
		}

		execl(path, name, NULL);
		tst_brk(TBROK | TERRNO, "Failed to exec reproducer");
	}

	while (!waitpid(pid, &status, WNOHANG)) {
		rem = tst_timeout_remaining();

		if (!sent_kill && rem / exec_time_start < 0.5) {
			tst_res(TINFO, "Timeout; killing reproducer");

			TEST(kill(pid, SIGKILL));
			if (TST_RET == -1)
				tst_res(TWARN | TTERRNO, "kill() failed");
			else
				sent_kill = 1;
		}

		usleep(backoff);
		backoff = MIN(2 * backoff, 1000000);
	}

	if (tst_taint_check()) {
		tst_res(TFAIL, "Kernel is tainted");
	} else {
		tst_res(TPASS, "Kernel is not tainted");
	}
}

static struct tst_test test = {
	.setup = setup,
	.test_all = run,
	.options = options,
	.needs_tmpdir = 1,
	.forks_child = 1,
	.bufs = (struct tst_buffers[]) {
		{&msg, .size = sizeof(*msg)},
		{}
	}
};
